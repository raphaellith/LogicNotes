\section{Entailment, consistency and recursive languages}

\subsection{What is entailment?}

Let \(\Gamma\) be a set of sentences and let \(S\) be a first-order structure (\(L\)-structure). We say that \(S\) is a \emph{model} of \(\Gamma\) if for each sentence \(\phi\in\Gamma\) we have \(S\models\phi\). This is denoted as \(S\models\Gamma\).

Furthermore, we say that \(\Gamma\models\psi\) for some sentence \(\psi\) if every model of \(\Gamma\) is also a model of \(\psi\), i.e. \(S\models\Gamma\implies S\models\psi\). This is written as \(\Gamma\models\psi\).

It's worth taking a moment to review the many roles that the symbol ``\(\models\)'' takes on in first-order logic. This is summarised in table \ref{tab:Ch07-models-meaning}.
%
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Expression} & \textbf{Meaning}\\
        \hline
        \((D,I) \models_A \phi\) & \(\phi\) is true in the structure \((D, I)\) under the variable assignment \(A\).\\
        \hline
        \((D,I) \models \phi\) & \(\phi\) is valid in the structure \((D, I)\).\\
        \hline
        \(\models \phi\) & \(\phi\) is valid.\\
        \hline
        \(\mathcal{K}\models\phi\) & \(\phi\) is valid in all structures \((D, I) \in \mathcal{K}\).\\
        \hline
        \((D, I) \models\Sigma\) & For all \(\phi\in\Sigma\) we have \((D, I)\models\phi\).\\
        \hline
        \(\Sigma\models\phi\) & \(\Sigma\) entails \(\phi\). (Every model of \(\Sigma\) is a model of \(\phi\).)\\
        \hline
    \end{tabular}
    \caption{The various meanings of the symbol \(\models\) in first-order logic. Here, \((D, I)\) is a first-order structure with domain \(D\) and interpretation \(I\); \(A\) is a variable assignment; \(\phi\) is a formula; \(\mathcal{K}\) is a set of structures; and \(\Sigma\) is a set of sentences.}
    \label{tab:Ch07-models-meaning}
\end{table}



\subsection{Soundness, strong completeness and consistency}

Entailment has the following properties.
%
\begin{align*}
    \Gamma\vdash\phi&\implies\Gamma\models\phi \tag{Soundness}\\
    \Gamma\models\phi&\implies\Gamma\vdash\phi \tag{Strong completeness}
\end{align*}
%
Soundness states that if \(\phi\) holds under the assumptions \(\Gamma\) (as proven using a tableau or axiomatic system), then \(\Gamma\) entails \(\phi\). Strong completeness is the converse thereof.

If falsity is deducible from a set of sentences \(\Sigma\),
%
\[\Sigma\vdash\bot\]
%
then \(\Sigma\) is said to be \emph{inconsistent}. By soundness, we also have
%
\[\Sigma\models\bot\]
%
which means that any model where \(\Sigma\) holds is also a model where \(\bot\) holds. Since \(\bot\) is always false, this implies that \(\Sigma\) does not have a model.

On the contrary, if falsity is not deducible from \(\Sigma\), then \(\Sigma\) is said to be \emph{consistent}. By strong completeness (using the contrapositive), we have \(\Sigma\not\models\bot\), so \(\Sigma\) must have a model.



\subsection{Recursive and recursively enumerable languages}

A \emph{language} refers to a set of strings over a finite alphabet \(\Sigma\).

A language \(L\) is said to be \emph{recursive} (also called \emph{decidable} or \emph{computable}) if there exists a computer program that
%
\begin{itemize}
    \item takes an arbitrary string \(s\in\Sigma^{*}\) as input;
    \item correctly outputs \texttt{yes} if \(s\in L\) and \texttt{no} otherwise; and
    \item always terminates for any input.
\end{itemize}

For example, the set of all formulas of first-order logic is recursive, since it is possible to write a parser that decides whether a string is a well-formed formula. Meanwhile, the set of valid first-order statements form a language, but it is not recursive.

Moreover, a language \(L\) is \emph{recursively enumerable} (abbreviated \emph{r.e.}) if there exists a computer program that outputs strings from \(L\), only strings from \(L\), and will eventually output any given string from \(L\).

\begin{theorem}
    The set of valid statements in first-order logic is recursively enumerable.
\end{theorem}
\begin{proof}[Proof 1 --- using Hilbert-style axiomatic proof systems]
    Let \(c\) be an injective function that encodes any Hilbert-style first-order logic proof \[\overline{\phi} = (\phi_0, \phi_1, \phi_2, \cdots, \phi_{k-1})\] as a number \(c(\overline{\phi})\). Then, the following program will eventually output any first-order theorem in finite time.
    %
    \begin{lstlisting}[language=python, commentstyle=\color{gray}]
    for ($i=0$, $i$++, forever):
        if $i$ is the code of a proof:  # $\color{gray} i = c(\overline{\phi})$
            output the proved formula
    \end{lstlisting}
    %
    Hence proved.
\end{proof}
\begin{proof}[Proof 2 --- using predicate tableaus]
    Let \(\phi_0, \phi_1, \cdots\) be an enumeration of all formulas. Consider the following program.
    %
    \begin{lstlisting}[language=python, commentstyle=\color{gray}]
    tableaus = []
    for ($i=0$, $i$++, forever):
        create a new tableau $T_i$ with $\neg\phi_i$ at root
        tableaus.append($T_i$)

        for each $j \leq i$:
            if the $j$-th tableau $T_j$ can be expanded:
                expand $T_j$ once with fair schedule
                if $T_j$ becomes closed:
                    output $\phi_j$
    \end{lstlisting}
    %
    For any formula \(\phi_k\),
    %
    \begin{itemize}
        \item if \(\phi_k\) is not valid, then \(T_k\) never closes (by soundness); and
        \item if \(\phi_k\) is valid, then \(T_k\) will eventually close, resulting in \(\phi_k\) being outputted in finite time.
    \end{itemize}
    %
    Therefore, this program only outputs valid formulas, and any valid formula will eventually be outputted.
\end{proof}

\begin{theorem}
    All recursive sets are recursively enumerable.
\end{theorem}
\begin{proof}
    Let \(L\) be a recursive language. Let \(A\) be a terminating algorithm such that
    %
    \[
        A(s) = 
        \begin{cases}
            1 \hspace{2em}\text{if } s \in L\\
            0 \hspace{2em}\text{otherwise}
        \end{cases}
    \]
    %
    for any input string \(s\). We then construct the following program.
    %
    \begin{lstlisting}[language=python, commentstyle=\color{gray}]
    for each string $s$ (sorted first by increasing length, then alphabetically):
        if $A(s) = 1$:
            output $s$
    \end{lstlisting}
    %
    This program only outputs strings from \(L\), and each \(s\in L\) is eventually output. Therefore, \(L\) is recursively enumerable.
\end{proof}

Note that the converse of the above theorem does not hold. While all recursive sets are recursively enumerable, not all recursively enumerable sets are recursive.