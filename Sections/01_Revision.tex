\section{Revision: Syntax and semantics of propositional and first-order logic}

Formally, a \emph{logic} consists of three components:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Component} & \textbf{Describes...}\\
        \hline
        Syntax & The language and grammar for writing formulas\\
        \hline
        Semantics & How formulas are interpreted\\
        \hline
        Inference system (or proof system) & A syntactic device for proving true statements\\
        \hline
    \end{tabular}

    \caption{The three key components of a logic.}
    \label{tab:Ch01-components-of-a-logic}
\end{table}

This module concerns algorithms that automatically parse and determine the validity of a formula.


\subsection{Propositional logic}

\subsubsection{Syntax}

Formulas are constructed by applying negation, conjunction and disjunction to propositions. 
%
\begin{align*}
    \text{proposition} &\coloneq p \;\vert\; q \;\vert\; r \;\vert\; \cdots\\
    \text{formula} &\coloneq \text{proposition} \;\vert\; \neg \text{formula} \;\vert\; (\text{formula} \circ \text{formula})  \tag{where \(\circ\) is \(\land\), \(\lor\) or \(\rightarrow\)}
\end{align*}
%
A proposition or its negation is called a \emph{literal}\footnote{For example, \(p\) and \(\neg p\) are both literals, but \(\neg\neg q\) is not.}.

For any formula that isn't a proposition, the \emph{main connective} is the one with the largest scope. In other words, it is not in the scope of any other connective.
%
\[((p \land q) \;{\color{BrickRed} \lor}\; \neg (q \rightarrow r))\]
%
This is the connective with which evaluation begins. This is especially important when building parsers for algorithmically evaluating formulas.

Note that parsers working according to the above definition will recognise \((p \land q)\), but not \(p \land q\), as a formula. Regardless, throughout this document we will use a looser definition where brackets may be ommitted in unambiguous cases.


\subsubsection{Semantics}

A valuation is a function \(v\) that maps each proposition to a truth value in \(\{\top, \bot\}\).
    
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.9]
        \draw[rounded corners] (-3, 0) rectangle (-1, -4) {};
        \draw[rounded corners] (1, 0) rectangle (3, -4) {};

        \node[align=center, anchor=center] at (-2, -1) {\(p\)};
        \node[align=center, anchor=center] at (-2, -2) {\(q\)};
        \node[align=center, anchor=center] at (-2, -3) {\(r\)};

        \node[align=center, anchor=center] at (2, -1.5) {\(\top\)};
        \node[align=center, anchor=center] at (2, -2.5) {\(\bot\)};

        \draw[-Latex, very thick, BrickRed] (-1.75, -1) -- (1.75, -1.5) node[pos=0.5, anchor=south] {\(v\)};

        \draw[-Latex, very thick, BrickRed] (-1.75, -2) -- (1.75, -2.4);

        \draw[-Latex, very thick, BrickRed] (-1.75, -3) -- (1.75, -2.6);

        \node[anchor=north] at (-2, -4) {Propositions};

        \node[anchor=north] at (2, -4) {Truth values};
        
    \end{tikzpicture}
    \caption{A valuation maps propositions to truth values.}
    \label{fig:Ch01-valuation}
\end{figure}

A valuation \(v\) can be extended to a unique \emph{truth function} defined on all possible formulas. A truth function \(v'\) must satisfy
%
\begin{align*}
    v'(\neg \phi) = \top &\iff v'(\phi) = \bot\\
    v'(\phi \lor \psi) = \top &\iff v'(\phi) = \top \text{ or } v'(\psi) = \top\\
    v'(\phi \land \psi) = \top &\iff v'(\phi) = \top \text{ and } v'(\psi) = \top\\
    v'(\phi \rightarrow \psi) = \top &\iff v'(\phi) = \bot \text{ or } v'(\psi) = \top\\
    v'(\phi \leftrightarrow \psi) = \top &\iff v'(\phi) = v'(\psi)
\end{align*}
%
for all formulas \(\phi\) and \(\psi\). From now on we use \(v\) to denote the more general truth function.

The result of applying a valuation \(v\) to a formula \(\phi\) depends only on the propositional letters that occur in \(\phi\). 

A formula \(\phi\) is \emph{valid} if \(v(\phi) = \top\) for all valuations \(v\), which we denote as \(\models \phi\). A formula \(\phi\) is \emph{satisfiable} if \(v(\phi) = \top\) for at least one valuation \(v\). All valid formulas are satisfiable, but \emph{not} vice versa.

Two formulas \(\phi\) and \(\psi\) are \emph{logically equivalent}, written as \(\phi \equiv \psi\), if and only if for every valuation \(v\) we have \(v(\phi) = v(\psi)\).



\subsubsection{Truth tables}

Consider the propositional formula \(((p \lor \neg q) \land \neg (q \land r))\). We can check its validity and satisfiability by constructing its truth table.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c||c|c||c|}
        \hline
        \(p\) & \(q\) & \(r\) & \((p \lor \neg q)\) & \(\neg (q \land r)\) & \(((p \lor \neg q) \land \neg (q \land r))\)\\
        \hline
        0 & 0 & 0 & 1 & 1 & 1 \\
        \hline
        0 & 0 & 1 & 1 & 1 & 1 \\
        \hline
        0 & 1 & 0 & 0 & 1 & 0 \\
        \hline
        0 & 1 & 1 & 0 & 0 & 0\\
        \hline
        1 & 0 & 0 & 1 & 1 & 1 \\
        \hline
        1 & 0 & 1 & 1 & 1 & 1 \\
        \hline
        1 & 1 & 0 & 1 & 1 & 1 \\
        \hline
        1 & 1 & 1 & 1 & 0 & 0 \\
        \hline
    \end{tabular}

    \caption{The truth table for the formula \(((p \lor \neg q) \land \neg (q \land r))\).}
    \label{tab:Ch01-truth-table}
\end{table}

In this case, the formula is satisfiable but not valid.



\subsubsection{Parse trees}

A parser interprets the semantics of a formula by breaking down its symbols into a \emph{parse tree}, which shows the syntactic relation between symbols. For example, the formula \(((p \lor \neg q) \land \neg (q \land r))\) can be broken down into the following parse tree.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.6]
        \node (main-and) at (0,0)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(\land\)};
        \node (or) at (-2,-2)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(\lor\)};
        \node (right-neg) at (2,-2)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(\neg\)};
        \node (p) at (-3,-4)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(p\)};
        \node (left-neg) at (-1,-4)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(\neg\)};
        \node (and) at (2,-4)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(\land\)};
        \node (left-q) at (-1,-6)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(q\)};
        \node (right-q) at (1,-6)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(q\)};
        \node (r) at (3,-6)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(r\)};

        \draw[-Latex, thick] (main-and) -- (or);
        \draw[-Latex, thick] (main-and) -- (right-neg);
        \draw[-Latex, thick] (or) -- (p);
        \draw[-Latex, thick] (or) -- (left-neg);
        \draw[-Latex, thick] (right-neg) -- (and);
        \draw[-Latex, thick] (left-neg) -- (left-q);
        \draw[-Latex, thick] (and) -- (right-q);
        \draw[-Latex, thick] (and) -- (r);
    \end{tikzpicture}
    \caption{The parse tree for the formula \(((p \lor \neg q) \land \neg (q \land r))\).}
    \label{fig:Ch01-parse-tree}
\end{figure}



\subsubsection{Disjunctive normal form (DNF)}

A formula is said to be in \emph{disjunctive normal form} (DNF) if it is a disjunction of one or more conjunctions of one or more literals.
%
\begin{align*}
    \text{proposition} &\coloneq p \;\vert\; q \;\vert\; r \;\vert\; \cdots\\
    \text{literal} &\coloneq \text{proposition} \;\vert\; \neg\text{proposition}\\
    \text{conjunctiveClause} &\coloneq \text{literal} \;\vert\; \text{literal } \land \text{ conjunctiveClause}\\
    \text{DNF} &\coloneq \text{conjunctiveClause} \;\vert\; \text{conjunctiveClause } \lor \text{ DNF}
\end{align*}
%
Below is an example of a formula in DNF.
%
\[
    {\color{BrickRed}\underbrace{(p \land \neg q \land \neg r)}_{\substack{\text{conjunctive}\\\text{clause}}}}
    \lor
    {\color{BrickRed}\underbrace{(\neg p \land \neg q \land r)}_{\substack{\text{conjunctive}\\\text{clause}}}}
    \lor
    {\color{BrickRed}\underbrace{(q \land \neg r)}_{\substack{\text{conjunctive}\\\text{clause}}}}
\]

Any propositional formula has a DNF equivalent. For instance, the formula \((p \lor \neg q) \land \neg (q \land r)\) can be rewritten as follows.
%
\begin{align*}
    & (p \lor \neg q) \land \neg (q \land r)\\
    \iff & (p \lor \neg q) \land (\neg q \lor \neg r) \tag{De Morgan's law, to remove outer negation}\\
    \iff & {\color{BrickRed}((p \lor \neg q) \land \neg q)} \lor {\color{MidnightBlue}((p \lor \neg q) \land \neg r)} \tag{distributing conjunctions over disjunctions}\\
    \iff & {\color{BrickRed}(p \land \neg q) \lor (\neg q \land \neg q)} \lor {\color{MidnightBlue}(p \land \neg r) \lor (\neg q \land \neg r)} \tag{distributing conjunctions over disjunctions}\\
    \iff & {\color{BrickRed}(p \land \neg q) \lor \neg q} \lor {\color{MidnightBlue}(p \land \neg r) \lor (\neg q \land \neg r)}
\end{align*}

Alternatively, this can also be achieved by referring to the truth table. From Table \ref{tab:Ch01-truth-table}, we see that the formula can be written in DNF as
%
\[(\neg p \land \neg q \land \neg r) \lor (\neg p \land \neg q \land r) \lor (p \land \neg q \land \neg r)  \lor (p \land \neg q \land r)  \lor (p \land q \land \neg r)\text{.}\]



\subsubsection{Conjunctive normal form (CNF)}

A formula is said to be \emph{conjunctive normal form} (CNF) if it is a conjunction of one or more disjunctions of one or more literals.
%
\begin{align*}
    \text{disjunctiveClause} &\coloneq \text{literal} \;\vert\; \text{literal } \lor \text{ disjunctiveClause}\\
    \text{CNF} &\coloneq \text{disjunctiveClause} \;\vert\; \text{disjunctiveClause } \land \text{ CNF}
\end{align*}
%
Below is a formula in CNF.
%
\[
    {\color{BrickRed}\underbrace{(p \lor \neg q \lor \neg r)}_{\substack{\text{conjunctive}\\\text{clause}}}}
    \land
    {\color{BrickRed}\underbrace{(\neg p \lor q \lor r)}_{\substack{\text{conjunctive}\\\text{clause}}}}
\]

To find the CNF equivalent of a formula \(\phi\), we first express its negation \(\neg\phi\) in DNF. Then, we negate it again to get \(\neg\neg\phi\). Using De Morgan's law, the resultant formula will be in CNF.

For example, let \(\phi\) be the formula \((p \lor \neg q) \land \neg (q \land r)\). To rewrite it in CNF, we start by constructing the truth table of its negation \(\neg\phi\). This allows us to express \(\neg\phi\) in DNF.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c||c|c|}
        \hline
        \(p\) & \(q\) & \(r\) & \(((p \lor \neg q) \land \neg (q \land r))\) & Negation of \(((p \lor \neg q) \land \neg (q \land r))\)\\
        \hline
        0 & 0 & 0 & 1 & 0 \\
        \hline
        0 & 0 & 1 & 1 & 0 \\
        \hline
        0 & 1 & 0 & 0 & 1 \\
        \hline
        0 & 1 & 1 & 0 & 1 \\
        \hline
        1 & 0 & 0 & 1 & 0 \\
        \hline
        1 & 0 & 1 & 1 & 0 \\
        \hline
        1 & 1 & 0 & 1 & 0 \\
        \hline
        1 & 1 & 1 & 0 & 1 \\
        \hline
    \end{tabular}

    \caption{The truth table for the negation of \(((p \lor \neg q) \land \neg (q \land r))\). This is obtained by flipping the results of Table \ref{tab:Ch01-truth-table}.}
    \label{tab:Ch01-truth-table-of-negation}
\end{table}

Hence we have
%
\begin{align*}
    \neg\phi &= (\neg p \land q) \lor (p \land q \land r) \tag{DNF of \(\neg\phi\)}\\
    \neg\neg\phi &= \neg((\neg p \land q) \lor (p \land q \land r)) \tag{negating both sides}\\
    \phi &= (p \lor \neg q) \land (\neg p \lor \neg q \lor \neg r) \tag{double negation; De Morgan's laws}
\end{align*}
%
which gives us \(\phi\) in CNF.



\subsection{First-order logic}

\subsubsection{Syntax}

A first-order language \(L(C, F, P)\) is determined by a set \(C\) of constant symbols, a set \(F\) of function symbols and a non-empty set \(P\) of predicate symbols. Each function symbol and predicate symbol has an associated \emph{arity} \(n \in \mathbb{N}\). We write \(f^n\) and \(p^n\) to represent an \(n\)-ary function symbol and an \(n\)-ary predicate symbol respectively. Moreover, let \(V\) be a countably infinite set of variable symbols.
%
\begin{align*}
    \text{term} &\coloneq c \;\vert\; v \;\vert\; f^n (\text{term}_0, \text{term}_1, \cdots, \text{term}_{n-1}) \tag{where \(c \in C\), \(v \in V\) and \(f^n \in F\)}\\
    \text{atom} &\coloneq p^n (\text{term}_0, \text{term}_1, \cdots, \text{term}_{n-1}) \tag{where \(p^n \in P\)}\\
    \text{formula} &\coloneq \text{atom} \;\vert\; \neg \text{formula} \;\vert\; (\text{formula}_0 \lor \text{formula}_1) \;\vert\; \exists v\; \text{formula}  \tag{where \(v \in V\)}
\end{align*}
%
This definition is functionally complete. Formulas involving universal quantifiers, implications and equivalence symbols can always be rewritten using only symbols defined above.

A \emph{closed term} is a term with no variable symbols. A \emph{sentence} is a formula with no free variables.



\subsubsection{Semantics}

For a first-order language \(L(C, F, P)\), we may construct a corresponding first-order structure\footnote{Also known as an \(L\)-structure.} \(S = (D, I)\) where \(I = (I_c, I_f, I_p)\).
%
{\large
    \[
        S = (
            {\color{BrickRed}
                \underbrace{D}_{\substack{
                    \text{non-empty}\\
                    \text{domain}
                }}
            }
            ,
            {\color{MidnightBlue}
                \overbrace{(
                    I_c,
                    I_f,
                    I_p
                )}^{\text{interpretation } I}
            }
        )
    \]
}
%
Here,
\begin{itemize}
    \item \(I_c\) maps each constant symbol in \(C\) to an element of \(D\).
    \item \(I_f\) maps each \(n\)-ary function symbol in \(F\) to an \(n\)-ary function over \(D\).
    \item \(I_p\) maps each \(n\)-ary predicate symbol \(p \in P\) to an \(n\)-ary relation over \(D\) (i.e. a subset of \(D^n\)).
    \item We may occasionally use \(I\) to denote a general interpretation function where
    %
    \begin{align*}
        I(c) &= I_c (c) \tag{for all \(c \in C\)}\\
        I(f) &= I_f (f) \tag{for all \(f \in F\)}\\
        I(p) &= I_p (p) \tag{for all \(p \in P\)}
    \end{align*}
\end{itemize}

If \(P\) includes the equality symbol \(=\), then it is always interpreted as the binary relation of true equality.
%
\[I_p (=) = \{(d, d) : d \in D\}\]

Given a structure \(S = (D, I)\), a variable assignment \(A\) is a map from \(V\) to \(D\). For any variable \(v \in V\), two variable assignments \(A\) and \(A^{*}\) are said to be \(v\)-equivalent if \(A(x) = A^{*}(x)\) for all \(x \in V \setminus \{v\}\). In other words, two variable assignments are said to be \(v\)-equivalent if they are completely identical except possibly for the element in \(D\) assigned to \(v\). This is written as \(A \equiv_v A^{*}\).

Given a structure \(S\) and a variable assignment \(A\), we may interpret any term as follows.
%
\begin{align*}
    c^{S, A} &= I_c (c)\\
    v^{S, A} &= A(v)\\
    f^n (t_0, t_1, \cdots, t_{n-1})^{S, A} &= {\color{MidnightBlue} \underbrace{(I_f (f^n))}_{\substack{\text{interpreted}\\\text{function}}}} (t_0^{S, A}, t_1^{S, A}, \cdots, t_{n-1}^{S, A})
\end{align*}

Formulas are evaluated as follows.
%
\begin{align*}
    S \models_A p^n (t_0, t_1, \cdots, t_{n-1}) &\iff (t_0^{S, A}, t_1^{S, A}, \cdots, t_{n-1}^{S, A}) \in I_p (p^n)\\
    S \models_A \neg \text{formula} &\iff S \not\models_A \text{formula}\\
    S \models_A (\text{formula}_0 \lor \text{formula}_1) &\iff S \models_A \text{formula}_0 \text{ or } S \models_A \text{formula}_1\\
    % S \models_A (\text{formula}_0 \land \text{formula}_1) &\iff S \models_A \text{formula}_0 \text{ and } S \models_A \text{formula}_1\\
    % S \models_A (\text{formula}_0 \rightarrow \text{formula}_1) &\iff S \not\models_A \text{formula}_0 \text{ or } S \models_A \text{formula}_1\\
    S \models_A \exists v\; \text{formula} &\iff S \models_{A[x \mapsto d]} \text{formula for some } d \in D
\end{align*}

Given a structure \(S\) and a formula \(\phi\), we say that
%
\begin{itemize}
    \item \(\phi\) is ``valid in \(S\)'' if \(S \models_A \phi\) for every variable assignment \(A\). This is written as \(S \models \phi\).
    \item \(\phi\) is ``satisfiable in \(S\)'' if \(S \models_A \phi\) for some variable assignment \(A\).
    \item \(\phi\) is ``valid'' if \(\phi\) is valid in all possible structures. This is written as \(\models \phi\).
    \item \(\phi\) is ``satisfiable'' if there exists some structure in which \(\phi\) is satisfiable.
\end{itemize}
%
A formula \(\phi\) is valid if and only if \(\neg \phi\) is not satisfiable.
%
\begin{quote}
    \textbf{Proof.} Let \(\neg\phi\) be a formula that is not satisfiable. Hence we have
    %
    \begin{align*}
        \neg \exists S\; \exists A\;\;\; S \models_A \neg\phi &\iff \neg \exists S\; \exists A\;\;\; S \not\models_A \phi\\
        &\iff \forall S\; \neg \exists A\;\;\; S \not\models_A \phi\\
        &\iff \forall S\; \forall A\;\;\;  \neg S \not\models_A \phi\\
        &\iff \forall S\; \forall A\;\;\; S \models_A \phi
    \end{align*}
    %
    which means \(S\) is valid.
\end{quote}

If \(\phi\) is a sentence, then \(\phi\) is valid in \(S\) if and only if it is also satisfiable in \(S\).



\subsubsection{Example: Arithmetic in the set of natural numbers}

Consider the first-order language \(L(C, F, P)\) defined as follows. Also assume a countably infinite set \(V\) of variable symbols.
%
\begin{align*}
    C &= 1, 2, 3, \cdots \tag{constant symbols}\\
    F &= \{+, \times\} \tag{function symbols, both binary}\\
    P &= \{=, <\} \tag{predicate symbols, both binary}\\
    V &= \{x, y, z, \cdots\} \tag{variable symbols}
\end{align*}
%
A term is a string of symbols that represents a ``thing'' or an ``object'' --- this can be a constant, a variable, or a function output.
%
\begin{itemize}
    \item \(x\)
    \item \(1 + 3\)
    \item \(2 \times x + 1\)
\end{itemize}
%
Of the terms shown above, only the second one is a closed terms because it has no variable symbols.

An atom is a string of symbols that represents the output of a predicate, which is a truth value.
%
\begin{itemize}
    \item \(1 = 2\)
    \item \(y < 3\)
    \item \(x + 1 < 2 \times z + 3\)
\end{itemize}
%
Finally, a formula is constructed by applying negations, disjunctions, and existential quantifiers to atoms.
%
\begin{itemize}
    \item \(1 = 2 \;\land\; y < 3\)
    \item \(\neg \exists z\;\; x + 1 < 2 \times z + 3\)
\end{itemize}
%
The latter example is a sentence because all of its variable symbols are bounded.

For this particular first-order language, we may use the structure of ordinary arithmetic\footnote{There is also a similar structure \(R = (\mathbb{R}, I)\) where the domain is the set of real numbers.}, defined as \(N = \{\mathbb{N}, \{I_c, I_f, I_p\}\}\) where
%
\begin{itemize}
    \item \(I_c\) is a function that maps numerical symbols to the corresponding natural number.
    %
    \begin{align*}
        I_c (1) &= 1\\
        I_c (2) &= 2\\
        I_c (3) &= 3\\
        &\;\;\vdots
    \end{align*}

    \item \(I_f\) maps \(+\) and \(\times\) to the addition and multiplication operations in arithmetic respectively.
    
    \item \(I_p\) maps \(=\) and \(<\) to the following relations.
    %
    \begin{align*}
        I_p (=) &= \{(n, n) : n \in \mathbb{N}\}\\
        I_p (<) &= \{(m, n) \in \mathbb{N}^2 : m < n\}
    \end{align*}
\end{itemize}



\subsubsection{First-order structures and directed graphs}

Consider a first-order language with only one binary predicate symbol \(p\).
%
\[L(C, F, {\color{BrickRed} \{p\}})\]
%
Any first-order structure \(S = \{D, \{I_c, I_f, I_p\}\}\) for this language can be represented as a directed graph, where each vertex is an element of \(D\) and each directed edge represents an element of the relation \(I_p (p)\).

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node (d0) at (0,0)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(d_0\)};
        \node (d1) at (-2,-2)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(d_1\)};
        \node (d2) at (2,-2)[circle, draw=MidnightBlue, very thick, MidnightBlue, fill=MidnightBlue!20] {\(d_2\)};

        \draw[-Latex, thick] (d0) -- (d1) node[pos=0.5, left]{\((d_0, d_1) \in I_p (p)\)};

        \draw[-Latex, thick] (d0) -- (d2) node[pos=0.5, right]{\((d_0, d_2) \in I_p (p)\)};

        \draw[-Latex, thick] (d1) -- (d2) node[pos=0.5, below]{\((d_1, d_2) \in I_p (p)\)};
        
    \end{tikzpicture}
    \caption{The first-order structure \(S\) can be visualised as a directed graph.}
    \label{fig:Ch01-first-order-structure-as-directed-graph}
\end{figure}